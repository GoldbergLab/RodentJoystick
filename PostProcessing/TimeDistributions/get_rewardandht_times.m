function [data, dates, statistics] = get_rewardandht_times(dirlist, varargin )
%data = 
% get_rewardandht_times(dirlist, [hist_int, TIME_RANGE, combineflag])
%  returns histogram data for all valid trajectories for all days in dirlist -
%  it gives time distributions of:
%  all hold times, rewarded trajectory hold times, reward rate by
%  interval, reward_or_stop times (now the same as hold time), and
%  joystick onset to reward onset time
%
% OUTPUTS:
%
%   data :: cell array where each cell represents a day and has the
%       following format:
%       data{i} = 
%       [time, ht_hist, rw_or_stop_hist, rew_hist, rewrate, js2rew_hist]
%       time - bins generated by 0:hist_int:TIME_RANGE;
%       ht_hist - hold time histogram using time as bins
%       rw_or_stop_hist - reward or stop histogram using time as bins
%       rew_hist - hold times of rewarded trajectories histogram using time as bins
%       rewrate - reward rate for each interval defined by time bins
%       js2rew_hist - joystick onset to reward histogram
%
%   dates :: cell array of string representation of each day
%
%   statistics :: cell array of structs containing descriptive statistics
%   for each day
%
% ARGUMENTS:
%
%   dirlist :: list of directories corresponding to days (structs)
%
% OPTIONAL ARGS:
%
%   hist_int :: size of the bins for data generation (future histogram
%       plotting)
%       DEFAULT : 20
%
%   TIME_RANGE :: number that tells end time range
%       DEFAULT : 2000
%
%   combineflag :: flag indicating whether to combine all data (1) or leave
%       separated by day (0)
%       DEFAULT : 0

%% ARGUMENT MANIPULATION AND PRELIMINARY MANIPULATION
default = {20, 2000, 0};
numvarargs = length(varargin);
if numvarargs > 3
    error('too many arguments (> 5), only 1 required and 3 optional.');
end
[default{1:numvarargs}] = varargin{:};
[hist_int, TIME_RANGE, combineflag] = default{:};

[statslist, dates] = load_stats(dirlist, combineflag, 'traj_struct');
data = cell(length(statslist), 1);
statistics = cell(length(statslist), 1);
for i = 1:length(statslist)
    stats = statslist(i);
    [time, ht_hist, rw_or_stop_hist, rew_hist, rewrate_hist, js2rew_hist, tmpstats] = generate_data(stats, hist_int, TIME_RANGE);
    statistics{i} = tmpstats;
    data{i}=[time, ht_hist, rw_or_stop_hist, rew_hist, rewrate_hist, js2rew_hist];
end

end

function [time, ht_hist, rw_or_stop_hist, rew_hist, rewrate_hist, js2rew_hist, tmpstats] = generate_data(stats, hist_int, TIME_RANGE)
tstruct = stats.traj_struct;
time = 0:hist_int:TIME_RANGE;        
holdtimes = zeros(length(tstruct), 1);
rw_or_stop = zeros(length(tstruct), 1);
j =0; rewtimes = []; js2rew = [];
for k = 1:length(tstruct)
    holdtimes(k) = length(tstruct(k).magtraj); %Teja 
    rw_or_stop(k) = tstruct(k).rw_or_stop;
    if tstruct(k).rw == 1
        j = j+1;
        rewtimes(j) = length(tstruct(k).magtraj);
        js2rew(j) = tstruct(k).rw_onset;
    end
end
rewtimes = rewtimes';
js2rew = js2rew';
ht_hist = histc(holdtimes, time);
rw_or_stop_hist = histc(rw_or_stop, time);
if isempty(rewtimes)
    rew_hist = zeros(length(time), 1);
    js2rew_hist = zeros(length(time), 1);
else
    rew_hist = histc(rewtimes, time);
    js2rew_hist = histc(js2rew, time);
end

rewrate_hist = (rew_hist./ht_hist);

ht_hist = (ht_hist./sum(ht_hist));
rw_or_stop_hist = (rw_or_stop_hist./sum(rw_or_stop_hist));
rew_hist = (rew_hist./sum(rew_hist));
js2rew_hist = (js2rew_hist./sum(js2rew_hist));

tmpstats.reward = prctile(rewtimes, [25 50 75]);
tmpstats.reward(4) = mean(rewtimes);
tmpstats.reward(5) = std(rewtimes);
tmpstats.ht = prctile(holdtimes, [25 50 75]);
tmpstats.ht(4) = mean(holdtimes);
tmpstats.ht(5) = std(holdtimes);
tmpstats.js2rew = prctile(js2rew, [25 50 75]);
tmpstats.js2rew(4) = mean(js2rew);
tmpstats.js2rew(5) = std(js2rew);
tmpstats.rw_or_stop = prctile(rw_or_stop, [25 50 75]);
tmpstats.rw_or_stop(4) = mean(rw_or_stop);
tmpstats.rw_or_stop(5) = std(rw_or_stop);
time = time';
end

