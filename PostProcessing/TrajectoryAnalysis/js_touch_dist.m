% js_touch_dist(stats, [interv, targ_time,targ_reward,dist_thresh, 
%       all_traj_flag, plotflag, smoothparam, ax, color]) 
%
%   takes the stats structure, a target hold time, a target reward 
%   percentage, and a distance threshold and computes a recommended hold
%   threshold while also generating a hold time distribution
%   This hold time distribution looks only at the maximum length of a
%   continuous segment under dist_thresh for a trial. This shows a
%   distribution of hold times without the swats.
%
% ARGUMENTS: 
%
%   stats :: data structure generated by xy_getstats
%       required field: traj_struct
%
% OPTIONAL ARGS:
%
%   interv :: interval for plotting (ms)
%       DEFAULT - 20
%
%   targ_time :: target hold time (ms)
%       DEFAULT - 300
%
%   targ_reward :: target reward, decimal representation of desired 
%       percentage of trials to be rewarded
%       DEFAULT - 0.25
%
%   dist_thresh :: the contingency used for the mice training - only looks
%       at trajectories to 
%       DEFAULT - 50
%
%   all_traj_flag :: if all_traj_flag == 1, function looks at all valid
%       trajectories within the nosepoke - otherwise, function only
%       examines the hold time of the max contact.
%       DEFAULT - 1
%
%   plotflag :: if plotflag > 0, function generates a plot, otherwise only
%       returns dist.
%       DEFAULT - 0
%
%   smoothparam :: smoothing parameter (only affects final plotting, not
%       data returned
%       DEFAULT - 1 (no smoothing)
%   
%   ax :: an axes handle (can be empty). If empty and plotflag enabled,
%       js_touch_dist generates a new figure and axes
%       DEFAULT - []
%
%   color :: optional color argument for plotting (used by
%       multi_js_touch_dist)
%       DEFAULT - 'r'
%
% OUTPUTS:
%
%   set_dist :: the recommended threshold for the center hold threshold
%
%   holddist_vect :: the hold time distribution (histogram, vector of
%       counts)
%
%   med_time :: the median hold time using the js_touch_dist 
%   
function [set_dist, holddist_vect, med_time, holdlength] = js_touch_dist(stats, varargin)
default = {20, 300, 0.25, 50, 1, 0, 1, [], 'r'};
numvarargs = length(varargin);
if numvarargs > 9
    error('too many arguments (> 10), only 1 required and 9 optional.');
end
[default{1:numvarargs}] = varargin{:};
[interv, targ_time, targ_reward, dist_thresh, all_traj_flag, plotflag, ...
    smoothparam, ax, color] = default{:};
if plotflag>0 && length(ax)<1;
    figure;
    ax = gca();
end

tstruct=stats.traj_struct;
start_prev=0;
rw_only=0;

holdlength=[];

for stlen=1:length(tstruct)
    if (tstruct(stlen).rw == rw_only) || ~rw_only
            holdlength(end+1) = getmaxcontlength(tstruct(stlen).magtraj,dist_thresh);
    end
end

k=0;
holdlength_prev=0;

for stlen=1:length(tstruct)
    if (tstruct(stlen).rw == rw_only) || ~rw_only
        k=k+1;
        if tstruct(stlen).rw_or_stop>targ_time            
            dist_distri(k) = max(tstruct(stlen).magtraj(1:targ_time));
        else
            dist_distri(k) = 6.35;
        end
    end
end

%dist_distri=dist_distri(dist_distri>0);
end_time_range = 1000;
dist_time_hld = 0:interv:end_time_range;
normalize = 1;
holddist_vect = histc(holdlength,dist_time_hld);
if normalize
    holddist_vect = holddist_vect./(sum(holddist_vect));
end
if plotflag == 1;
    ext = '';
elseif plotflag == 2;
    ext = ' (Laser Only)';
elseif plotflag == 3;
    ext = ' (No Laser Only)';
elseif plotflag == 4;
    ext = ' (No Laser Only - Resampled)';
end
if plotflag
    axes(ax);
    hold on;
    stairs(dist_time_hld, smooth(holddist_vect, smoothparam),color,'LineWidth',1);
    xlabel('Hold Time');
    ylabel('Proportion');
    title(['JS Touch Hold Time Distr', ext]);
    hold off;
end

time_success = length(dist_distri)/k;
c = histc(dist_distri,(1:1:100)*(6.35/100));
success_prob = cumsum(c)/sum(c);
med_time = median(holdlength);
targ_dist = find(success_prob>(targ_reward/time_success));
if numel(targ_dist)>0
    set_dist = targ_dist(1);
else
    set_dist = 100;
end